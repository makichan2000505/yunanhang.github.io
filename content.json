[{"title":"Node.js+Express+EJS入门笔记","slug":null,"date":"2016-05-27T10:10:11.000Z","updated":null,"comments":null,"path":"2016/05/27/Node.js+Express+EJS入门笔记/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Node.js+Express+EJS入门笔记标签（空格分隔）： 未分类 什么是EJSEJS的优势就是，我们可以使用它来给页面创建局部的视图。举个例子，你可以让所有页面使用公共的头部，脚部，和导航栏，并且只需用EJS改变页面里的内容。你也可以把数据传到视图里，举个例子，每个用户都有不同的用户名。使用EJS，可以这样改变页面里的用户名显示。123app.get(&apos;/&apos;,function(req,res)&#123;res.render(&apos;index&apos;,&#123;user:“Gone Lee”&#125;)&#125;); 这样在每次加载index页面时，会动态地调用不同的用户名并显示出来。以名字为例，你能够使用JavaScript来生成HTML和EJS。 创建一个简单的EJS模块。 在你的项目里创建一个视图文件夹。 创建一个index.ejs 12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;welcome &lt;%= user%&gt;;&lt;/body&gt;&lt;/html&gt; 搞定，现在你已经用EJS创建你的第一个模块了。代码中&lt;%= title %&gt;的作用是绑定了一个标题，稍后有详细解释。现在你该做的是使用EJS view engine（EJS的视图引擎）从你的node服务器来渲染这个index.ejs。 渲染EJS 创建一个 server.js 文件，并安装ejs 模板 创建你的express app实例 12345678var express = require(&apos;express&apos;); var app = express();Now, Inside you server.js set the view Engine to ejs as followsapp.set(&apos;view engine&apos;, &apos;ejs&apos;);Create a route for your app.app.get(&apos;/&apos;, function(req, res)&#123; res.render(&apos;index&apos;,&#123;user: &quot;Great User&quot;,title:&quot;homepage&quot;&#125;); &#125;); 还记得我们之前在index.ejs中写的代码吗，我们已经把title和user的标签用&lt;%%&gt;符号绑定在页面里了，在这个渲染函数里，我们就要把这些参数传到ejs里面去。 大功告成，运行你的server.js 创建局部的视图到此为止，我们已经会使用动态的数据和渲染函数创建了一个单独的视图。现在试试创建嵌套的视图。 用如下代码重写index.js里的内容 12345678&lt;html&gt;&lt;head&gt;&lt;% include(&apos;header.ejs&apos;) %&gt;&lt;/head&gt;&lt;body&gt;&lt;% include(&apos;body.ejs&apos;) %&gt;&lt;/body&gt;&lt;/html&gt; 现在在文件夹里创建另外两个文件header.ejs 1234567&lt;title&gt;Hello World&lt;/title&gt;body.ejs&lt;div&gt;Welcome, Great User&lt;/div&gt; 启动服务器。现在你已经把局部视图（header.ejs）嵌入到主视图index.ejs里面去了. 使用javascript你可以使用javascript来实现ejs的模块化。下面看看如何实现。 在index.js里写入如下代码 12345&lt;ul&gt;&lt;% users.forEach(function(user)&#123; %&gt;&lt;%= user.name %&gt;&lt;% &#125;)%&gt;&lt;/ul&gt; 现在渲染index.ejs并把一个对象数组传到渲染函数里去。代码如下: 1234567app.get(&apos;/&apos;, function(req, res)&#123; res.render(&apos;index&apos;,[; &#123; name: &apos;John&apos; &#125;,; &#123; name: &apos;Mike&apos; &#125;,; &#123; name: &apos;Samantha&apos; &#125;; ]); &#125;); 这里使用的是数组传递到渲染对象并使用EJS列出每个用户的名字。 总结EJS使HTML和数据分离，而且大大加强了代码的重用。许多静态博客系统都使用了EJS模板。使整个网页目录结构更加干净清晰。","raw":null,"content":null,"categories":null,"tags":[]},{"title":"克隆数组","slug":null,"date":"2016-05-21T12:33:44.000Z","updated":null,"comments":null,"path":"2016/05/21/克隆数组/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1.浅表克隆1234567891011121314var person = new Person();var person.sex=&quot;male&quot;;var person.age=28;//创建一个新数组var oArray =[&quot;tom&quot;,person];var newArray = oArray.concat();//调用concat函数，返回一个新的数组对象.同样也可用slice函数document.write(oArray[1].age);//28document.write(newArray[1].age);//28person.age = 29;document.write(oArray[1].age);//29document.write(newArray[1].age);//29oArray[1].age = 30;document.write(person.age);//30document.write(newArray[1].age);//30 浅表克隆操作的是同一个引用 2.深度克隆123456/***@param _array 被克隆的数组*@param deep 定义是否深度克隆*@return Array 返回克隆的数组*@throws Error 参数数量不正确**/ 深度克隆，不断进行索引，复制原始数组中的所有对象，从而使新数组不再和原始数组指向同一个引用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function cloneArray(_array,deep)&#123; //如果参数数量为1，为浅表克隆 if(arguments.length==1) &#123; var isdeep=false; &#125; //否则为深表克隆 else if&#123; var isdeep = deep; &#125; //否则抛出报错 else&#123; throw new Error(&quot;参数数量不正确&quot;); return; &#125; //判断被克隆数组是否是数组对象，若是，返回[]，否则返回&#123;&#125;,并把返回值传给变量newArray var newArray = _array instanceof Array?[]:&#123;&#125;; if(isdeep) /*如果是深度克隆*/ &#123; //首先遍历该数组 for(var i in _array) &#123; var prop = _array[i];/*把数组里的元素指向变量prop*/ if(typeof prop ==&apos;object&apos;)/*如果该元素为对象*/ &#123; if(prop instanceof Array)/*如果该元素为数组对象，也就是数组中的数组,就要用push函数*/ &#123; var newArray[i] = [];/*创建数组newArray*/ for(var j = 0;j&lt;prop.length;j++)&#123; if(typeof prop[j]!=&apos;object&apos;)/*for循环里再次判断该数组里的元素是否为对象*/ &#123; newArray[i].push(prop[j]);/*如果不是对象了，就可以直接把元素push进newArray*/ &#125; else &#123; newArray[i].push(cloneArray(prop[j],true));/*如果还是对象，那就再次调用cloneArray函数进行递归，处理该对象并push进newArray*/ &#125; &#125; &#125; else /*如果是不是数组对象，而是其他类型的对象，不用push*/ &#123; newArray[i] = cloneArray(prop.true); &#125; &#125; else /*如果该元素不是对象*/ &#123; newArray[i] = prop; &#125; &#125; &#125; else /*如果不是深度克隆*/ &#123; newArray = _array.concat(); &#125; return newArray;&#125; 测试123456789101112131415//创建一个复杂数据类型作为数组元素var person = new Object();person.sex = &quot;male&quot;person.age = 28;var oArray =[&quot;jack&quot;,person];//克隆var newArray = cloneArray(oArray,true);document.write(oArray[1].age);/*28*/document.write(newArray[1].age);/*28*///改变指向的对象person.age = 27;document.write(oArray[1].age);/*27*/document.write(newArray[1].age);/*28*/ 3.深度克隆意义复制一个对象，改变原对象的属性，克隆的对象不受影响。例如在游戏引擎中，复制出一个模型，改变克隆出的模型的长宽高不会影响原模型的长宽高，这时就会用到深度克隆。","raw":null,"content":null,"categories":null,"tags":[]}]